# =============================================================================
# -     -   -  -  -  - - ---Условия, циклы и рекурсии--- - -  -  -  -   -     -
# =============================================================================
'''
В зоопарке цена входного билета зависит от возраста
посетителя. Дети до двух лет и пенсионеры старше 65 лет
допускаются бесплатно. Дети в возрасте от трех до 12 лет
могут посещать зоопарк за 200 рублей. Обычный взрослый билет стоит 500 рублей.

Напишите программу, которая будет запрашивать
возраст всех посетителей в группе по одному за раз
и выводить общую цену билетов для посещения зоопарка
этой группой. Общую цену билетов стоит выводить в
формате с двумя знаками после запятой.
'''
from multiprocessing.resource_tracker import unregister
from operator import index
from time import asctime

# def total_sum():
#     total_price = 0
#     person_old = 0
#
#     print('Для остановки программы напишите "-1" при вводе возраста человека')
#
#     while person_old != -1:
#         person_old = int(input('\nВведите возраст человека: '))
#         if person_old <= 2 or person_old > 65:
#             total_price += 0
#             print(f'Общая сумма: {total_price:.2f} руб.')
#         elif person_old >= 3 and not person_old > 12:
#             total_price += 200
#             print(f'Общая сумма: {total_price:.2f} руб.')
#         else:
#             total_price += 500
#             print(f'Общая сумма: {total_price:.2f} руб.')
#
#     print(f'\n\nИтоговая общая сумма: {total_price:.2f} руб.\nЗавершение программы!')
#
#
# total_sum()
#
# def total_sum():
#     total_price = 0
#     print('Для остановки программы напишите "-1" при вводе возраста человека')
#
#     while True:
#         user_input = input('\nВведите возраст человека: ').strip()
#
#         # Проверка на завершение
#         if user_input == "-1":
#             break
#
#         # Проверка, что введено число
#         if not user_input.isdigit():
#             print("Ошибка: введите положительное число или -1 для выхода.")
#             continue
#
#         age = int(user_input)
#
#         # Расчёт стоимости билета
#         if age <= 2 or age > 65:
#             price = 0
#         elif 3 <= age <= 12:
#             price = 200
#         else:
#             price = 500
#
#         total_price += price
#         print(f'Общая сумма: {total_price:.2f} руб.')
#
#     print(f'\nИтоговая сумма за всех: {total_price:.2f} руб.\nЗавершение программы.')
#
# total_sum()

'''
Юлию Цезарю необходимо было посылать секретные
письменные приказы своим генералам. В результате
он стал шифровать свои послания довольно простым
методом, который теперь называют кодом Цезаря.
Идея шифрования заключалась в циклическом сдвиге
букв на три позиции. В итоге буква A превращалась в D,
B – в E, C – в F и т. д. Последние три буквы алфавита
переносились на начало. Таким образом, буква X
становилась A, Y – B, а Z – C.
Цифры и другие символы не подвергались шифрованию.

Важно: буквы идут по алфавиту в кодировке Юникод.
Большие и маленькие буквы находятся в кодировке
в разных местах, поэтому обрабатывать переход нужно
отдельно для заглавных и строчных букв.
Для проверки символов можно использовать функции
isalpha() — буква ли это, и isupper() — заглавная ли
это буква.
Напишите программу, которая реализует код Цезаря
для латинского алфавита. Позвольте пользователю
ввести фразу, после чего выведите результат.
'''
# def cezar_code():
#     lowercase_letters = [
#         'a', 'b', 'c', 'd', 'e', 'f', 'g',
#         'h', 'i', 'j', 'k', 'l', 'm', 'n',
#         'o', 'p', 'q', 'r', 's', 't', 'u',
#         'v', 'w', 'x', 'y', 'z'
#     ]
#     uppercase_letters = [
#         'A', 'B', 'C', 'D', 'E', 'F', 'G',
#         'H', 'I', 'J', 'K', 'L', 'M', 'N',
#         'O', 'P', 'Q', 'R', 'S', 'T', 'U',
#         'V', 'W', 'X', 'Y', 'Z'
#     ]
#     text = input('Введите текст для шифровки: ')
#     text_new = []
#     for letter in text:
#         if letter.isalpha():
#             if letter.isupper():
#                 if letter not in ['X', 'Y', 'Z']:
#                     i = uppercase_letters.index(letter)
#                     i += 3
#                     text_new.append(uppercase_letters[i])
#                 else:
#                     i = uppercase_letters.index(letter)
#                     i -= 23
#                     text_new.append(uppercase_letters[i])
#             else:
#                 if letter not in ['x', 'y', 'z'] :
#                     i = lowercase_letters.index(letter)
#                     i += 3
#                     text_new.append(lowercase_letters[i])
#                 else :
#                     i = lowercase_letters.index(letter)
#                     i -= 23
#                     text_new.append(lowercase_letters[i])
#         else:
#             text_new.append(letter)
#
#     return ''.join(text_new)
#
#
# print(cezar_code())

'''
Изучите список:

a = [1, 1, 2, 3, 5, 8, 34, 55, 89].

Напишите код: выведите все элементы списка, которые
меньше 5.
'''
# a = [1, 1, 2, 3, 5, 8, 34, 55, 89]
# b = []
# for i in a:
#     if i < 5:
#         b.append(i)
# print(b)

'''
Напишите программу: запросите у пользователя целое
число и выведите на экран информацию о том, четное
оно или нечетное.
'''
# def check_num():
#     number = int(input(f'Введите число: '))
#     return 'четное' if number % 2 == 0 else 'нечетное'
#
# print(check_num())

'''
Напишите программу для отображения стандартной
таблицы умножения от единицы до десяти. Убедитесь, 
что ваша таблица умножения имеет заголовки над первой строкой и слева от первого столбца.

Важно: в этом задании вам нужно выводить значения 
на экран без принудительного перевода курсора 
на строку ниже. Для этого задайте end="" в качестве
последнего аргумента функции print.

Например, функция print("A") выведет на экран букву
A, после чего автоматически перейдет на новую строку.
Так print("A", end="") не станет переводить курсор, 
и позволит произвести следующий вывод в той же строке.
'''
# for i in range(1, 11):
#     print(f"{i:>2}", end="")  # заголовок слева
#     for j in range(2, 11):
#         print(f"{i * j:>4}", end="")  # красиво выравненное тело
#     print()  # перенос строки

'''
Для выигрыша главного приза нужно, чтобы 6 номеров
на лотерейном билете совпали с шестью числами,
которые выпали случайным образом в диапазоне от 1 до 49. 

Напишите программу, которая будет случайным образом
подбирать шесть номеров для вашего билета. Убедитесь,
что среди этих чисел не будет дубликатов. Выведите
номера билетов на экран по возрастанию.

Важно: в коде используйте функцию random.sample().
'''
# import random
# ticket = random.sample(range(1, 50), 6)
# ticket.sort()
#
# print("Ваши лотерейные номера:", ticket)

'''
Напишите программу, которая будет запрашивать
у пользователя целочисленные значения и сохранять
их в виде списка. 

Чтобы закончить ввод значений, пользователь должен
ввести 0. 

Затем программа выведет на экран все числа, кроме 0,
в порядке возрастания — по одному значению в строке.
'''
# list_ = []
# number = True
#
# while number != 0:
#     number = int(input('Введите число: '))
#     list_.append(number)
#
# list_.remove(0)
# list_.sort()
# for i in list_:
#     print(i)

'''
Гарри, Рон и Гермиона отправляются на поиски крестражей. Как им удалось узнать, 
один из крестражей спрятан в хранилище Гринготтса — специального банка для волшебников.

Друзья приняли решение использовать зелье невидимости. Лучше всего это зелье работает в туманную погоду.

Помогите волшебникам выбрать дни для поиска крестражей. Создайте функцию search_day(), 
которая посчитает количество туманных дней в списке. 
Она принимает в качестве аргумента список с предположительной влажностью воздуха на ближайшие пять дней. 
Например, такой: 76, 89, 91, 32, 10. Если влажность превышает 80%, день считается туманным. 
Верните список с порядковыми номерами туманных дней. Номера дней считайте с нуля.
'''
# def search_day(humidity_list):
#     result = []
#     for index, humidity in enumerate(humidity_list):
#         if humidity > 80:
#             result.append(index)
#     return result
#
#
# humidity_list = [76, 89, 91, 32, 10]
#
#
# print(search_day(humidity_list))

'''
Теперь, когда волшебники определились с днем, в который они проникнут в Гринготтс, 
им необходимо распределить задачи между собой. Гермиона составила список задач:

Приготовить зелье невидимости.
Собрать вещи и подготовить снаряжение.
Раздобыть оборотное зелье.
Чтобы распределить задачи честно, Гермиона заколдовала три стакана с водой. 
Если дотронуться до стакана волшебной палочкой, вода в нем поменяет цвет.

Каждому цвету соответствует своя задача:
— если цвет окажется красным, то волшебник займется первой задачей;
— если цвет окажется синим, то волшебник займется второй задачей;
— если цвет окажется зеленым, то волшебник займется третьей задачей;
— если волшебнику выпадет любой другой цвет, значит, заклинание сработало некорректно.

Напишите программу, которая поможет волшебникам определить, какой задачей им нужно заняться. 
Создайте функцию task_check(), которая принимает на вход строку с названием цвета. 
Цвета передаются на английском языке. Функция должна вернуть номер задачи, 
которой соответствует цвет, или ноль, если цвету не соответствует ни одна задача.
'''
# def task_check():
#     task_colors = {
#         'red' : 1,
#         'blue' : 2,
#         'green' : 3
#     }
#     color = input('Введите название цвета на английском: ')
#     return task_colors.get(color, 0)
#
# print(task_check())

'''
Гермионе выпала первая задача — она должна приготовить зелье невидимости. 
У этого зелья несложный рецепт, но нужно быть очень внимательной.

Гермионе нужно помешивать зелье конкретное количество раз, чтобы оно получилось правильным. 
Она помечает все помешивания на пергаменте. 
Общее количество помешиваний должно соответствовать одному из условий:

— делится на 4 и не делится на 100;

— делится на 400.

Напишите функцию potion_check(), которая проверит, помешала ли Гермиона зелье правильное количество раз. 
Она должна принимать на вход один аргумент — число, которое обозначает, сколько раз Гермиона помешала зелье. 
В качестве результата работы функции верните yes, если количество помешиваний верное, или no в обратном случае. 
Используйте операторы and и or, чтобы скомбинировать несколько условий в одном if.
'''
# def potion_check(n):
#     return 'yes' if (n % 4 == 0 and n % 100 != 0) or n % 400 == 0 else 'no'
#
#
# n = 399
#
# print(potion_check(n))

'''
Рону досталась вторая задача — собрать вещи и подготовить снаряжение. Рон составил список необходимых вещей:

— мантия-невидимка;
— волшебная палочка;
— набор зелий;
— карта;
— оберег от проклятий.

Рон не очень внимательный и боится забыть что-то важное и взять что-то лишнее. 
Помогите ему — создайте функцию importance_check(), которая проверит, нужно ли брать предмет с собой. 
Она принимает на вход один аргумент — название предмета, который можно взять. 
Названия предметов передаются на русском языке, все необходимые предметы называются так же, как они названы в списке выше. 
Если предмет входит в список и его нужно взять, верните 1. Если не входит — значит, брать его не нужно, верните 0.
'''

# def importance_check(item):
#     return int(item in ['мантия-невидимка', 'волшебная палочка', 'набор зелий', 'карта', 'оберег от проклятий'])
#
# item = 'мантия-'
#
# print(importance_check(item))

'''
Известно, что фамилии всех студентов Дурмстранга в Лютном переулке оканчиваются "ов". 
Создайте функцию student_suspect(), которая определит, подходящая ли фамилия у предполагаемого студента. 
Функция принимает на вход один аргумент — строку с фамилией студента. 
Если фамилия оканчивается на "ов", верните «Лови!». 
В любом ином случае верните «Пропусти его»
'''
# def student_suspect(text):
#     return 'Лови!' if text[-2:] == 'ов' else 'Пропусти его'
#
# text = 'Кабшанов'
#
# print(student_suspect(text))

'''
На каждой двери есть номер из четырех цифр. Если номер является палиндромом, то дверь безопасна. 
Палиндром — это строка, которая одинаково читается в обоих направлениях. 
Например, строка «1331» — это палиндром.

Напишите функцию security_check(), которая проверит, безопасно ли выходить через определенную дверь. 
Функция принимает один аргумент — строку с последовательностью цифр на двери. 
Проверьте, является ли строка палиндромом. 
Если да, то верните «Безопасно». В любом ином случае верните «Ловушка».
'''
# def security_check(text):
#     return 'Безопасно' if text[::-1][0:2] == text[:2] else 'Ловушка'

'''
КиберКодер — известный в узких кругах хакер. Уже много лет его занимает одна задача. 
Он хочет взломать шифр, за которым прячется ответ на главный вопрос Вселенной. 
КиберКодеру очень бы пригодилась ваша помощь.

Для первого этапа взлома КиберКодеру нужно подобрать номера портов сервера, к которым он сможет подключиться. 
Известно, что это четные числа, которые находятся в определенном диапазоне.

Напишите функцию even_numbers(), которая найдет все четные числа в диапазоне. 
Она принимает два аргумента — начало и конец промежутка, внутри которого нужно будет найти четные цифры. 
Сохраните в список все четные числа в заданном диапазоне и верните этот список в качестве ответа.
'''
# def even_numbers(a, b):
#     even = []
#
#     for i in range(a, b+1):
#         if i % 2 == 0:
#             even.append(i)
#
#     return even
#
# a = 1
# b = 10
#
# print(even_numbers(a, b))

'''
Создайте функцию directories_check(), которая принимает один аргумент — список целых чисел. 
Каждое число в этом списке — это номер директории. 
Функция должна сохранить все нечетные номера в отдельный список и вернуть его в качестве ответа. 
Если в исходном списке встретилась директория с номером 359, 
остановите проверку и сохраните только те нечетные числа, которые попали в список до 359. 
Число 359 не должно попасть в ответ.
'''
# def directories_check(list_):
#     even_list = []
#
#     for i in list_:
#         if i == 359:
#             break
#         if i % 2 != 0:
#             even_list.append(i)
#
#     return even_list
#
#
# list_ = [2, 4, 6, 8, 10]

'''
Создайте функцию crosscheck(), которая принимает на вход два аргумента — два списка целых чисел. 
Функция должна найти числа, которые есть сразу в двух списках. 
В качестве ответа верните список этих чисел. Используйте циклы для решения задачи.
'''
# list_number_1 = [3, 7, 12, 5, 9, 21, 14, 8, 18, 11]
# list_number_2 = [5, 9, 14, 22, 3, 17, 25, 11, 30, 7]
#
# def crosscheck(list1, list2):
#     joint_number  = []
#
#     for i in list1:
#         if i in list2:
#             joint_number.append(i)
#
#     return joint_number
#
#
# print(crosscheck(list_number_1, list_number_2))

'''
Создайте функцию unique_key(), которая принимает один аргумент — целое положительное число. 
Функция unique_key должна найти сумму всех цифр числа из аргумента. 
Верните эту сумму в качестве ответа. Используйте цикл while для решения задачи.
'''
# Создайте функцию unique_key
# def unique_key(number):
#         # Создайте переменную, в которой сохраните итоговую сумму
#     digit_sum = 0
#
#     # Используйте цикл while, чтобы разбить число на цифры.
#     # Пока в числе еще есть цифры, действия будут повторяться.
#     while number > 0:
#             # Получите последнюю цифру числа
#         digit = number % 10
#         # Добавьте полученную цифру к итоговой сумме
#         digit_sum += digit
#         # Удалите цифру, которую вы обработали, из числа
#         number //= 10
#
#     # Верните сумму цифр числа в качестве ответа
#     return digit_sum
#
# a=538
#
# print(unique_key(a))

'''
Создайте функцию count_letters(), которая посчитает, сколько раз буква повторяется в строке. 
Функция должна принимать два аргумента — строку, которую нужно проанализировать, 
и букву, частоту повторения которой нужно найти. 
В качестве ответа верните одно число — количество повторений буквы в строке.
'''
# def count_letters(str_, substr_):
#     result = 0
#
#     for i in str_.lower():
#         if i == substr_:
#             result +=1
#
#     return result
#
#
# print(count_letters('KabshanovK', 'k'))

'''
Напишите функцию decipher(), которая заменит все числа в строке на буквы русского алфавита. 
Функция должна принимать один аргумент — строку с целыми числами от 0 до 32, между которыми стоит пробел. 
В качестве ответа верните строку с последовательностью букв без пробелов и других разделителей. 
Используйте только строчные буквы.
'''
# def decipher(string_number):
#     russian_letters = [
#         'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й',
#         'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф',
#         'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я'
#     ]
#     string_number_list = string_number.split(' ')
#     decrypted_text = []
#     for number in string_number_list:
#         letter_number = int(number)
#         letter = russian_letters[letter_number]
#         decrypted_text.append(letter)
#
#
#     return ''.join(decrypted_text)
#
#
# a = '0 1 2'
#
# print(decipher(a))

'''
Создайте функцию all_dividers(), которая найдет все делители числа. 
Она должна принимать на вход один аргумент — число, которое нужно разложить на множители. 
В качестве ответа верните список со всеми делителями исходного числа.
'''
# def all_dividers(number) :
#     list_number = []
#     for i in range(1, number + 1) :
#         if number % i == 0 :
#             list_number.append(i)
#
#     return list_number
#
#
# print(all_dividers(12))

'''
Модуль time в Python позволяет работать со временем.
Вам потребуется функция asctime. Она считывает
текущее время компьютера и возвращает его в удобном
виде. Напишите программу: используйте эту функцию 
для отображения на экране текущей даты и времени. 
'''
# import time
#
# print(time.asctime())

'''
Напишите программу, которая будет находить самое
длинное слово в файле. 

В качестве результата программа должна выводить 
на экран длину самого длинного слова и все слова
такой длины. 

Важно: принимайте за значимые буквы любые символы,
включая цифры и знаки препинания, но не пробелы.
'''
# def search_long_word():
#     with open('texx.txt', 'r', encoding='utf-8') as file:
#         text = file.read()
#         words = text.split()
#         max_len = max(len(word) for word in words)
#         long_words = [word for word in words if len(word) == max_len]
#
#     print(f"Максимальная длина: {max_len}")
#     print("Слова такой длины:")
#     for word in long_words :
#         print(word)
#
#
# search_long_word()

'''
Напишите программу, которая будет считывать содержимое файла, 
добавлять к считанным строкам порядковый номер и сохранять их в таком виде в новом файле. 

Имя исходного файла и имя целевого файла необходимо
запросить у пользователя. 

Каждая строка в созданном файле должна начинаться 
с ее номера, двоеточия и пробела, после чего должен
идти текст строки из исходного файла.

Важно: чтобы разбить содержимое файла на строки,
используйте функцию readlines()
'''
# def read_file():
#     orig_file = input('введите название файла: ')
#     new_file = input('введите название нового файла: ')
#     strings_ = ''
#
#     with open(orig_file, 'r', encoding='utf-8') as in_file:
#         text = in_file.readlines()
#
#     for i, word in enumerate(text):
#         strings_ += f'{i+1}: {word}'
#
#     with open(new_file, 'w', encoding='utf-8') as out_file:
#         out_file.write(strings_)
#
#
# read_file()

'''
Напишите программу: выведите на экран объединенное
содержимое нескольких файлов, имена которых
передаются ей в качестве аргументов. При этом файлы
должны объединяться в том порядке, в котором указаны
в аргументах. 

В процессе работы программа должна выдавать сообщения о том, 
какие файлы открыть не удается, и переходить к следующим файлам. 

Если программа была запущена без аргументов, 
на экран должно быть выведено сообщение об ошибке.

Важно: для того, чтобы код корректно обрабатывал
ошибку, используйте конструкцию try-except.
'''
# def combine_files(*file_names):
#     if len(file_names) == 0:
#         print("Ошибка: файлы на указаны.")
#         return
#     else:
#         combine_file = ''
#         for file_name in file_names:
#             try:
#                 with open(file_name, 'r', encoding='utf-8') as file:
#                     combine_file += file.read()
#             except:
#                 print(f"Файл {file_name} не открывается.")
#
#         print(combine_file)
#
#
# combine_files('new.txt', 'texx.txt')
'''
В языке Python для создания комментариев в коде используется символ #. Комментарий начинается с этого
символа и продолжается до конца строки. 

Напишите программу, которая будет удалять все комментарии из исходного файла с кодом на языке Python.

Важно: пусть программа просматривает каждую строку
с помощью функции readlines(). Программа должна
удалить все содержимое, после символа # и до конца
строки с помощью функции split().

Сохраните новое содержимое в созданном файле.
Имена файла источника и файла назначения должны
быть запрошены у пользователя. Удостоверьтесь, 
что программа корректно обрабатывает ошибки 
при работе с обоими файлами
'''
# def delete_comment():
#     name_file = input('Введите название файла для обработки: ')
#     new_name_file = input('Введите новое название файла после обработки: ')
#     new_text_file = []
#
#     # Открываем и читаем файл, создаем список
#     with open(name_file, 'r', encoding='utf-8') as file:
#         text_file = list(file.readlines())
#
#     # Запускаем цикл для удаления > # и сохраняем результат в новый список
#     for strings in text_file:
#         if '#' in strings:
#             strings = strings.split('#')[0].rstrip()
#         new_text_file.append(strings)
#
#     new_text_file_string = ''.join(new_text_file)
#
#     with open(new_name_file, 'w', encoding='utf-8') as out_file:
#         out_file.write(new_text_file_string)
#
#     return new_name_file
#
#
# print(delete_comment())
'''
Цель задания — научиться делать кортеж «плоским» или возвращать список, 
состоящий из элементов всех подсписков исходного кортежа.

Задание
Напишите функцию flatten_tuple, которая принимает на вход кортеж tup, 
содержащий внутри себя другие кортежи (подсписки). 
Функция должна вернуть список, состоящий из всех элементов подсписков.
'''
# # пример вложенного (двухуровневого) кортежа
# demo_tuple = (
#     (1, 2, 3),          # числа
#     ('a', 'b'),         # буквы
#     (True, False, None) # булевы значения и None
# )
#
# # твоя функция
# def flatten_tuple(tup):
#     return [el for subarr in tup for el in subarr]
#
# # проверяем
# result = flatten_tuple(demo_tuple)
# print(result)           # → [1, 2, 3, 'a', 'b', True, False, None]
'''
Домашнее задание №51: Как посчитать сумму с условием
Цель задания — научиться считать сумму с условием с помощью list comprehentions.

Задание
Напишите функцию sum_positive_numbers, 
которая принимает список целых чисел numbers 
и возвращает сумму только положительных чисел из данного списка.
'''
# num = [1, -1, 3, 5, -5]
# def sum_positive_numbers(numbers):
#     return sum([num for num in numbers if num > 0])
#
# print(sum_positive_numbers(num))
'''
Цель задания — научиться обрабатывать массив с условием с помощью list comprehentions.

Задание
Напишите функцию process_array, которая принимает список целых чисел numbers и возвращает новый список, 
содержащий только положительные числа, умноженные на 2.
'''
# def process_array(numbers):
#     return [num * 2 for num in numbers if num > 0]
'''
Цель задания — научиться формировать словарь с помощью list comprehentions.

Задание
Напишите функцию list_to_dict, которая принимает список ключей и список значений. 
А затем возвращает словарь, сформированный из этих списков. 
Используйте генератор списка и специальную функцию.
'''
# a = [1, 2]
# b = ['a', 'b']
# def list_to_dict(list_key, list_value):
#     return {key: value for key, value in zip(list_key, list_value)}
#
# print(list_to_dict(a, b))
'''
Цель задания — научиться найти максимальное значение меньше заданного.

Задание
Создайте функцию lim_max(nums, limit), которая принимает на вход кортеж чисел nums и ограничение limit.
Инициализируйте переменную max_value со значением -1, которая будет хранить максимальное значение, строго меньшее limit.
Пройдитесь циклом по элементам кортежа nums.
Внутри цикла проверьте каждый элемент кортежа на условие: элемент должен быть строго меньше limit и больше текущего значения max_value.
Если условие выполняется, обновите значение max_value на текущий элемент.
По окончанию цикла, верните значение max_value.
'''
# def lim_max(nums, limit):
#     max_value = -1
#     for num in nums:
#         if num < limit and num > max_value:
#             max_value = num
#
#     return max_value
#

'''
Напишите функцию check_list, которая принимает на вход переменную var и проверяет, является ли она списком.
def check_list(var):
    return isinstance(var, list)

'''
'''
Напишите функцию get_value_by_index, которая принимает на вход список ref_list и индекс index. 
Функция должна вернуть значение списка ref_list по указанному индексу, 
если список ref_list не равен None, является списком (а не другим типом данных) 
и индекс не выходит за пределы длины списка. 
В любом ином случае верните значение None.
'''
# def get_value_by_index(ref_list, index):
#     if ref_list is not None and isinstance(ref_list, list) and 0 <= index < len(ref_list):
#         return ref_list[index]
#     else:
#         return None
'''
Напишите функцию list_reorder, которая принимает на вход список списков list_of_lists. 
Функция должна изменить структуру списка, так чтобы элементы из вложенных списков стали элементами одного общего списка.
'''
# list_1 = [1, 2]
# list_2 = [3, 4]
# list_3 = [5, 6]
# def list_reorder(*list_of_lists):
#     result = [el for subarr in list_of_lists for el in subarr]
#     return result
#
# print(list_reorder(list_1, list_2, list_3))
'''
Напишите функцию list_insert, которая принимает на вход: 
список ref_list, индекс start, число num, и количество повторений rep. 
Функция должна вставить число num в список ref_list начиная с позиции start, повторяя его rep раз.
'''
# ref_list = [1,2,3]
# num = 22
# start = 2
# rep = 5
#
# def list_insert(ref_list, start, num, rep):
#     if len(ref_list) < start:
#         return -1
#
#     ref_list[start:start] = [num,] * rep
#
#     return ref_list
#
# # Проверка
# print(list_insert(ref_list, start, num, rep))
'''
Напишите функцию generate_values, которая принимает на вход начальное значение start и конечное значение end. 
Функция должна вернуть список значений в заданном числовом интервале от start до end (включительно).
'''
# def generate_values1(start, end):
#     return [el for el in range(start, end-1, -1)]
#
# print(generate_values1(10, 1))
#
# def generate_values(start, end):
#     fwd = 1 if start <= end else -1
#     return list(range(start, end + 1 * fwd, 1 * fwd))
#
# print(generate_values(10, 1))
'''
Даны два словаря dict1 и dict2. 
Напишите функцию merge_dicts, которая объединит эти два словаря в один с помощью оператора объединения и вернет результат.
'''
# dict1 = {1: 2}
# dict2 = {'aa': 'a'}
# def merge_dicts(dict1, dict2):
#     return dict1 | dict2
#
# print(merge_dicts(dict1,dict2))

'''
Даны два словаря dict1 и dict2. Напишите функцию merge_dicts, которая объединит эти два словаря. 
В начале результирующего словаря должны идти ключи dict1. 
Значения с общими ключами должны стать элементами общего списка в результирующем словаре. 
Функция merge_dicts должна вернуть результирующий словарь.
'''
# dict1 = {'a': 1, 'b': 2}
# dict2 = {'b': 3, 'c': 4}
#
#
# def merge_dicts(dict1, dict2):
#     result = dict1.copy()
#
#     for d2 in dict2:
#         if d2 in result:
#             result[d2] = [result[d2], dict2[d2]]
#         else:
#             result[d2] = dict2.get(d2)
#
#     return result
#
# print(merge_dicts(dict1, dict2))
'''
Напишите функцию count_elements, которая принимает на вход коллекцию 
(список, кортеж, множество или строку) и возвращает словарь. 
В нем ключами должны быть уникальные элементы коллекции, а значениями - количество их вхождений в данную коллекцию. 
В результате верните получивышийся словарь.
'''
a= ['a', 'b', 'c', 'a']
# def count_elements(array):
#     result = {}
#
#     for el in array:
#         if el not in result:
#             result[el] = 1
#         else:
#             result[el] += 1
#
#     return result
#
#
# print(count_elements(a))
'''
Напишите функцию get_value, которая принимает на вход словарь data и ключ key. 
Функция должна возвращать значение из словаря data, соответствующее переданному ключу key. 
Если ключ отсутствует в словаре, функция должна возвращать строку "Key not found".
'''
# def get_value(data: dict, key):
#     if key in data:
#          return data[key]
#     else:
#         return f'Key not found'
#
# print(get_value({1: 2, 'a' : 'abc'}, 1))
'''
Напишите функцию sort_dict, которая принимает на вход словарь d, 
тип сортировки type (keywise или valuewise) 
и порядок сортировки order (asc или desc). 
Функция должна возвращать отсортированный словарь по ключам или значениям, 
в зависимости от переданных параметров.
'''
d = {'b': 3, 'a': 1, 'c': 2}

def sort_dict(d, type, order):
    if type == "keywise":
        idx = 0
    else:
        idx = 1

    if order == "desc":
        reverse_check = True
    else:
        reverse_check = False

    return dict(sorted(d.items(), key=lambda x: x[idx], reverse=reverse_check))

print(sort_dict(d, type="valuewise", order="asc"))





















